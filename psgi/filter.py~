#!/usr/bin/env python
import numpy as np
import modest
import logging
import h5py
import scipy
import misc
from misc import funtime

logger = logging.getLogger(__name__)

def state_parser(Ns,Ds,Nv,Nx,Dx):
  out = {}

  out['Ns'] = Ns
  out['Ds'] = Ds
  out['Nv'] = Nv
  out['Nx'] = Nx
  out['Dx'] = Dx
  out['total'] = 3*Ns*Ds + Nv + 2*Nx*Dx

  slip_integral = range(0,Ns*Ds)
  out['slip_integral'] = np.reshape(slip_integral,(Ns,Ds))

  slip = range(Ns*Ds,2*Ns*Ds)
  out['slip'] = np.reshape(slip,(Ns,Ds))

  slip_derivative = range(2*Ns*Ds,3*Ns*Ds)
  out['slip_derivative'] = np.reshape(slip_derivative,(Ns,Ds))

  out['fluidity'] = range(3*Ns*Ds,3*Ns*Ds + Nv)

  secular_velocity = range(3*Ns*Ds + Nv,3*Ns*Ds + Nv + Nx*Dx)
  out['secular_velocity'] = np.reshape(secular_velocity,(Nx,Dx))

  baseline = range(3*Ns*Ds + Nv + Nx*Dx,3*Ns*Ds + Nv + 2*Nx*Dx)
  out['baseline_displacement'] = np.reshape(baseline,(Nx,Dx))

  return out


def flat_data(u):
  '''                            
  takes a Nx by Dx array of data and flattens it to one dimension   
  '''
  return np.reshape(u,(np.prod(np.shape(u)),))


def flat_covariance(C):
  '''               
  takes a Nx by Dx by Dx covariance array and flattens it to two  
  dimension             
  '''
  return scipy.linalg.block_diag(*C)


@funtime
def observation(X,t,F,G,p,flatten=True):
  # This version enforces nonnegativity in viscosity
  tect = (X[p['secular_velocity']]*t + X[p['baseline_displacement']])
  slip = np.einsum('ijkl,ij',F,X[p['slip']])
  visc = np.einsum('ijklm,ij,k',G,X[p['slip_integral']],
                                  np.exp(X[p['fluidity']]))

  out = tect + slip + visc

  if flatten:
    out = flat_data(out)

  return out


@funtime
def regularization(reg_matrix,state,p):
  state = np.array(state,copy=True)
  state[p['fluidity']] = np.exp(state[p['fluidity']])

  out = reg_matrix.dot(state)
  return out


@funtime
def observation_augmented(X,t,F,G,p,reg_matrix,flatten=True):
  out = observation(X,t,F,G,p,flatten)
  reg = regularization(reg_matrix,X,p)
  out = np.hstack((out,reg))
  return out


@funtime
def observation_jacobian(X,t,F,G,p):
  # This version enforces nonnegativity in viscosity
  # change F from slip,slip_dir,disp,disp_dir to 
  # disp,disp_dir,slip,slip_dir
  F = np.einsum('ijkl->klij',F)
  # change G from slip,slip_dir,visc,disp,disp_dir to 
  # disp,disp_dir,visc,slip,slip_dir
  G = np.einsum('ijklm->lmkij',G)
  jac = np.zeros((p['Nx'],p['Dx'],p['total']))
  jac_vel = t*np.eye(p['Dx']*p['Nx']).reshape(p['Nx'],p['Dx'],p['Nx'],p['Dx'])
  jac_disp = np.eye(p['Dx']*p['Nx']).reshape(p['Nx'],p['Dx'],p['Nx'],p['Dx'])
  jac[:,:,p['secular_velocity']] = jac_vel
  jac[:,:,p['baseline_displacement']] = jac_disp
  jac[:,:,p['slip']] = F
  jac[:,:,p['slip_integral']] = np.einsum('ijklm,k',G,np.exp(X[p['fluidity']]))
  # exp(fluidity) is being broadcast along the middle axis in G
  jac[:,:,p['fluidity']] = np.einsum('ij...lm,lm,...->ij...',
                                     G,
                                     X[p['slip_integral']],
                                     np.exp(X[p['fluidity']]))

  jac = np.reshape(jac,(p['Nx']*p['Dx'],p['total']))   
  return jac
  

@funtime
def regularization_jacobian(reg_matrix,state,p):
  '''combines slip and fluidity regularization matrix and modifies
     the fluidity regularization matrix for nonnegativity'''
  #flu_reg = fluidity_regularization(state[p['fluidity']])
  # form the full regularization matrix
  reg_matrix = np.array(reg_matrix,copy=True)
  reg_matrix[:,p['fluidity']] *= np.exp(state[p['fluidity']])
  return reg_matrix


@funtime
def observation_jacobian_augmented(X,t,F,G,p,reg_matrix):
  jac = observation_jacobian(X,t,F,G,p)
  reg = regularization_jacobian(reg_matrix,X,p)
  jac = np.vstack((jac,reg))
  return jac


@funtime
def transition(X,dt,p):
  Xout = np.copy(X)
  Xout[p['slip_integral']] = (X[p['slip_integral']] +
                              X[p['slip']]*dt +
                              X[p['slip_derivative']]*0.5*dt**2)

  Xout[p['slip']] = (X[p['slip']] +
                     X[p['slip_derivative']]*dt)

  return Xout


@funtime
def process_covariance(X,dt,alpha,jump_times,p):
  jump_times = np.asarray(jump_times)
  Q = np.zeros((p['total'],p['total']))
  Q[p['slip_derivative'],p['slip_derivative']] = alpha**2*dt
  Q[p['slip'],p['slip']] = alpha**2*(dt**3)/3.0
  Q[p['slip_integral'],p['slip_integral']] = alpha**2*(dt**5)/20.0
 
  Q[p['slip_integral'],p['slip']] = alpha**2*(dt**4)/8.0
  Q[p['slip'],p['slip_integral']] = alpha**2*(dt**4)/8.0

  Q[p['slip_derivative'],p['slip']] = alpha**2*(dt**2)/2.0
  Q[p['slip'],p['slip_derivative']] = alpha**2*(dt**2)/2.0
 
  Q[p['slip_derivative'],p['slip_integral']] = alpha**2*(dt**3)/6.0
  Q[p['slip_integral'],p['slip_derivative']] = alpha**2*(dt**3)/6.0

  return Q


def RMSE(data,predicted,covariance):
  res = data - predicted
  covinv = np.linalg.inv(covariance)
  return np.sqrt(np.einsum('ijk,ijkl,ijl',res,covinv,res))


def form_regularization(reg,p):
  reg_matrix = np.zeros((0,p['total']))
  for i,v in reg.iteritems():
    print(np.shape(p[i]))
    #if len(np.shape(p[i])) == 2:
    if len(np.shape(v)) == 3:
      for j in range(np.shape(v)[2]):
        r1 = v[:,:,j]
        r2 = np.zeros((len(r1),p['total']))
        r2[:,p[i][:,j]] = r1
        reg_matrix = np.vstack((reg_matrix,r2))

    else:
      r1 = v[:,:]
      r2 = np.zeros((len(r1),p['total']))
      r2[:,p[i]] = r1
      reg_matrix = np.vstack((reg_matrix,r2))

  return reg_matrix  

def form_prior(prior,p):
  Xprior = np.zeros(p['total'])  
  Cprior = 1e-10*np.eye(p['total'],p['total'])
  for i,v in prior.iteritems():
    if i == 'fluidity':
      flu_prior = v['mean'][...]
      flu_prior_cov = v['covariance'][...] 
      # convert the fluidity prior to prior for exp(fluidity) 
      flu_prior_cov = flu_prior_cov/(flu_prior**2)
      flu_prior = np.log(flu_prior)
      vnew = {}
      vnew['mean'] = flu_prior
      vnew['covariance'] = flu_prior_cov
      v = vnew

    if len(np.shape(v['mean'])) == 2:
      for j in range(np.shape(v['mean'])[1]):
        idx = p[i][:,j]
        Xprior[idx] = v['mean'][:,j]  
        Cprior[np.ix_(idx,idx)] = v['covariance'][:,j,:,j]
    else:
      idx = p[i]
      Xprior[idx] = v['mean'][:]  
      Cprior[np.ix_(idx,idx)] = v['covariance'][...]

  return Xprior,Cprior

@funtime
def kalmanfilter(data,gf,reg,prior,param,outfile):
  '''
  Nt: number of time steps
  Nx: number of positions
  Dx: spatial dimensions of coordinates and displacements 
  Ns: number of slip basis functions per slip direction
  Ds: number of slip directions
  Nv: number of fluidity basis functions
  total: number of state parameters (Ns*Ds + Nv + 2*Nx*Dx)

  Parameters
  ----------
    data: \ mean : (Nt,Nx,Dx) array
          \ covariance : (Nt,Nx,Dx,Dx) array
          \ metadata \ position : (Nx,Dx) array
                       time : (Nt,) array

    prior: \ mean : (total,) array
           \ covariance : (total,total) array

    gf: \ elastic : (Ns,Ds,Nx,Dx) array
        \ viscoelastic : (Ns,Ds,Dv,Nx,Dx) array
        \ metadata \ position : (Nx,Dx) array

    reg: \ regularization : (*,total) array

    params: user parameter dictionary

    

  Returns
  -------
    out: \ slip_integral \ mean : (Nt,Ns,Ds) array
                         \ uncertainty :(Nt,Ns,Ds) array
         \ slip \ mean : (Nt,Ns,Ds) array
                \ uncertainty : (Nt,Ns,Ds) array
         \ slip_derivative \ mean : (Nt,Ns,Ds) array
                           \ uncertainty : (Nt,Ns,Ds) array
         \ fluidity \ mean : (Nv,) array
                    \ uncertainty : (Nv,) array
         \ secular_velocity \ mean : (Nx,Dx) array
                            \ uncertainty : (Nx,Dx) array
         \ baseline_displacement \ mean : (Nx,Dx) array
                                 \ uncertainty : (Nx,Dx) array

  '''
  F = gf['slip'][...]
  G = gf['fluidity'][...]

  alpha = param['slip_acceleration_variance']
  jump_times = param['jump_times']
  u = data['mean']
  Cd = data['covariance']
  t = data['time']

  Ns,Ds,Nv,Nx,Dx = np.shape(G)
  Nt = len(t)

  # check for consistency between input
  assert np.shape(u) == (Nt,Nx,Dx)
  assert np.shape(Cd) == (Nt,Nx,Dx,Dx)
  assert np.shape(F) == (Ns,Ds,Nx,Dx)
  assert np.shape(G) == (Ns,Ds,Nv,Nx,Dx)
  p = state_parser(Ns,Ds,Nv,Nx,Dx)

  Xprior,Cprior = form_prior(prior,p)   
  reg_matrix = form_regularization(reg,p)
  reg_rows = len(reg_matrix)  

  kalman = modest.KalmanFilter(
             Xprior,Cprior,
             observation_augmented,
             obs_args=(F,G,p,reg_matrix),
             ojac=observation_jacobian_augmented,
             ojac_args=(F,G,p,reg_matrix),
             trans=transition,
             trans_args=(p,),
             pcov=process_covariance,
             pcov_args=(alpha,jump_times,p),
             solver_kwargs={'maxitr':param['maxitr']})

  
  # prepare outfile file
  for k in p.keys():
    if k == 'total':
      outfile[k] = np.zeros((Nt,p[k]))

    else:
      outfile[k] = np.zeros((Nt,)+np.shape(p[k]))

  logger.info('starting Kalman filter iterations')
  for i in range(Nt):
    flat_ui = flat_data(u[i,...])
    flat_ui = np.hstack((flat_ui,np.zeros(reg_rows)))
    flat_Cdi = flat_covariance(Cd[i,...])
    flat_Cdi = scipy.linalg.block_diag(flat_Cdi,np.eye(reg_rows))
    prior = kalman.get_prior()
    kalman.update(flat_ui,flat_Cdi,t[i])
    if i != (Nt - 1):
      if np.any((t[i+1] > jump_times) & (t[i] <= jump_times)):
        logger.info('increasing slip variance by 100x when updating '
                    'from t=%s to t=%s' % (t[i+1],t[i]))
        kalman.pcov_args = (100*alpha,jump_times,p)
        kalman.predict(t[i+1]-t[i])           
        kalman.pcov_args = (alpha,jump_times,p)

      else:
        kalman.predict(t[i+1]-t[i])    

    for k in p.keys():
      if k == 'total':
        outfile[k][i,:] = kalman.state['posterior']

      else:
        outfile[k][i,...] = kalman.state['posterior'][p[k]]


    logger.info('finished Kalman filter iteration %s of %s' % (i+1,Nt))

  #logger.info('smoothing with RTS method')
  #kalman.smooth()

  #state_mean = kalman.get_state_history('posterior')
  #state_covariance = kalman.get_state_history('posterior_covariance')
  
  ############ DELETE THIS LINE LATER ##################
  #state_mean = kalman.get_state_history('posterior')
  #state_covariance = kalman.get_state_history('posterior_covariance')
  ######################################################

  #state_std = [np.sqrt(np.diag(i)) for i in state_covariance]

  logger.info('computing predicted data')
  # compute predicted data
  pred = np.zeros((Nt,p['Nx'],p['Dx']))
  for i in range(Nt):
    pred[i,:,:] = observation(outfile['total'][i],t[i],F,G,p,flatten=False)

  outfile['predicted'] = pred

  error = RMSE(u,pred,Cd)
  logger.info('total RMSE: %s' % error)
  # compute predicted tectonic
  #tect_pred = np.zeros((Nt,p['Nx'],p['Dx']))
  #mask = np.zeros(p['total'])
  #mask[p['secular_velocity']] = 1.0
  #mask[p['baseline_displacement']] = 1.0
  #for i in range(Nt):
  #  tect_pred[i,:,:] = observation(state_mean[i]*mask,t[i],F,G,p,flatten=False)

  # compute predicted elastic deformation
  #slip_pred = np.zeros((Nt,p['Nx'],p['Dx']))
  #mask = np.zeros(p['total'])
  #mask[p['slip']] = 1.0
  #for i in range(Nt):
  #  slip_pred[i,:,:] = observation(state_mean[i]*mask,t[i],F,G,p,flatten=False)

  # compute predicted viscoelastic deformation
  #visc_pred = pred - slip_pred - tect_pred

  #slip_int = {'mean':np.array([i[p['slip_integral']] for i in state_mean]),   
  #            'uncertainty':np.array([i[p['slip_integral']] for i in state_std])}

  #slip = {'mean':np.array([i[p['slip']] for i in state_mean]),   
  #        'uncertainty':np.array([i[p['slip']] for i in state_std])}

  #slip_dif = {'mean':np.array([i[p['slip_derivative']] for i in state_mean]),   
  #            'uncertainty':np.array([i[p['slip_derivative']] for i in state_std])}

  #visc = {'mean':state_mean[-1][p['fluidity']],   
  #        'uncertainty':state_std[-1][p['fluidity']]}

  #vel = {'mean':state_mean[-1][p['secular_velocity']],   
  #       'uncertainty':state_std[-1][p['secular_velocity']]}

  #base = {'mean':state_mean[-1][p['baseline_displacement']],   
  #        'uncertainty':state_std[-1][p['baseline_displacement']]}

  #state_soln = {'slip_integral':slip_int,
  #              'slip':slip,
  #              'slip_derivative':slip_dif,
  #              'fluidity':visc,
  #              'secular_velocity':vel,
  #              'baseline_displacement':base,
  #              'metadata':{'time':t}}

  #out_file = {'state':state_soln,
  #       'predicted':pred}

  return 


